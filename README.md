Проект Heroes - это итоговой проект по предмету "Алгоритмы и структуры данных". В нем реализовано 4 метода, описанных ниже.

# 1. Метод generate интерфейса GeneratePreset
Метод отвечает за генерацию пресета армии противника.  
Разберём алгоритмическую сложность метода generate

## 1. Сортировка юнитов 
**Сложность:** $O(n \log n)$, где $n$ — размер `unitList`.

## 2. Основной цикл по юнитам
**Сложность:** $O(n)$, так как цикл выполняется **$n$ раз** (по числу юнитов).

## 3. Назначение координат
**Сложность** $O(11n) = O(n)$.

## Итоговая сложность
Суммируем все этапы:
1. Сортировка: $O(n \log n)$.  
2. Основной цикл: $O(n)$.  
3. Назначение координат: $O(n)$.  

**Общая алгоритмическая сложность:**  
$O(n \log n) + O(n) + O(n) = \boxed{O(n \log n)}$


# 2. Метод simulate интерфейса SimulateBattle

Метод отвечает за осуществление симуляции боя.
Разберём алгоритмическую сложность метода simulate

## 1. **Инициализация**  
**Сложность** $O(n + m)$, где *n* — количество юнитов в армии игрока, *m* — количество юнитов в армии компьютера.

## 2. **Основной цикл**  
**Сложность** $O(min(n, m))$
   - Цикл выполняется, пока обе армии не опустеют.  
   - В худшем случае каждый юнит погибает только после одного полного цикла (атака + контратака).  

## 3. **Метод `executeAttacks`**  
**Сложность** $O(k)$

## Итоговая сложность

- **В худшем случае** (когда каждый юнит атакует ровно один раз перед гибелью):  
  - Основной цикл выполняется $O(min(n, m))$ раз.  
  - На каждой итерации вызывается `executeAttacks` дважды: для атакующей и обороняющейся армии.  
  - В каждом вызове `executeAttacks` обрабатывается $O(n)$ или $O(m)$ юнитов.  

- **Суммарная сложность**:  
  $O(\min(n, m) \cdot (n + m))$


# 3. Метод getSuitableUnits интерфейса SuitableForAttackUnitsFinder
Метод отвечает за создание перечня подходящих для атаки юнитов.  
Разберём алгоритмическую сложность метода getSuitableUnits

## 1. **Внешний цикл по строкам**  
 **Сложность** $O(R)$, где $R$ — количество строк.

## 2. **Поиск крайнего юнита** 
**Сложность** в среднем для каждой строки это $O(C_{avg})$, где $C_{avg}$ — средняя длина строки.

## 3. **Проверка блокировки**  
**Сложность** $O(C_b)$, где $C_b$ — длина блокирующей строки. Это проход по всей строке в поисках юнита с совпадающей координатой.

## 4. **Итого для одной итерации цикла**  
   $O(C_{r}) + O(C_{b}) = O(C_{max})$, где $C_{max}$ — максимальная длина строки.

## 5. **Общая сложность**  
   Умножаем на количество строк:  
   $O(R) \cdot O(C_{max}) = O(R \cdot C_{max})$

   Так как все строки одинаковой длины $C$, то:  
   $O(R \cdot C)$

   Это эквивалентно $O(N)$, где $N$ — общее количество юнитов во всех строках (поскольку $N = R \cdot C$ в среднем).

## Итоговая алгоритмическая сложность

$O(R \cdot C_{max})$ или $O(N)$, где:
- $R$ — количество строк,
- $C_{max}$ — максимальная длина строки,
- $N$ — общее число юнитов.


# 4. Метод getTargetPath интерфейса UnitTargetPathFinder
Метод отвечает за поиск наикратчайшего пути между атакующим и атакуемым юнитом.  
Разберём алгоритмическую сложность метода getTargetPath

## 1. **Инициализация** 
**Сложность** $O(W × H)$

## 2. **Основной цикл**  
**Сложность** общее число итераций цикла — не более *W × H*.

## 3. **Восстановление пути**  
**Сложность** $O(W + H)$

## Итоговая сложность

Алгоритмическая сложность данного — $O(W × H)$, где:
- *W* = 27 (ширина поля);
- *H* = 21 (высота поля).






















